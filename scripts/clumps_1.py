# This code (clump checker) is run on the dataset and clump_dataset file
# generated by image segmentation. In unusual cases, objects may be detected
# as both cells and aggregates, or a combination of many objects detected as
# cells may, in aggregate, be detected as a cell aggregate. This code is
# designed to check for aggregates whose area is substantially composed of
# objects detected as cells, and discard any such aggregates found (the
# image segmentation for cells is more sophisticated and more likely to be
# accurate).
#
# This code outputs a 'clump_corrected' file which is used by a subsequent
# analysis program, the 'clump selection.'

import numpy as np
import os
import sys
from StringIO import StringIO

expLabel = sys.argv[1]

# Open data files
cell_file = open(os.path.join(os.path.join(expLabel,'datasets'),expLabel+'_dataset.csv'),'r')
clump_file = open(os.path.join(os.path.join(expLabel,'datasets'),expLabel+'_clump_dataset.csv'),'r')

# Following blocks of code create output file
path = os.path.join(expLabel,'temp_files')
datefolder=path
filename = 'clump_corrected'
filetype = '.csv'
try: 
    os.makedirs(path)
except OSError:
    if not os.path.isdir(path):
        raise

path = os.path.join(path,expLabel+'_'+filename)
f = open(path+filetype,'w')

# Read in a line from the cell dataset
cell=cell_file.readline()
cell_data= np.genfromtxt(StringIO(cell),delimiter=',') # Parse the cell line data

minute = -1 
frame = -1
frame_cells=[]

for line in clump_file: # For each line in the clump file...
    clump = np.genfromtxt(StringIO(line),delimiter=',') # Parse the clump line data
    newMinute=clump[0]
    newFrame=clump[1]
    keepClump = True # Assume we will keep this clump
    if not (newMinute==minute and newFrame==frame): # If the cell and clump minutes/frames don't match...
        minute = newMinute # Set minute to the clump's minute
        frame = newFrame # Set frame to the clump's frame
        while cell_data[0] < minute or cell_data[1] < frame: # Read in (and discard) cells until the minute/frame is >= the clump's
            cell=cell_file.readline()
            cell_data= np.genfromtxt(StringIO(cell),delimiter=',')
        frame_cells=[] # Initialize a list for cells from the same image as the clump
        while cell_data[0] == minute and cell_data[1] == frame: # While (and if) the cell line data is from the same image as the clump...
            if cell_data[2]>0: # If the cell line object is labeled as a cell...
                frame_cells.append(cell_data) # Record this data
            cell=cell_file.readline() # Read in the next cell line
            cell_data= np.genfromtxt(StringIO(cell),delimiter=',')
            
    clump_cells=[] # List of cells known to have centers well within the clump's center
    radius=np.sqrt((float(clump[4])/np.pi))/2.0 # Assuming the clump is circular, use the clump's area to find its radius, then divide by two
    for i in frame_cells: # For all cells in the same image as the clump
        if np.abs(i[3]-clump[2]) < radius and np.abs(i[4]-clump[3]) < radius:   # Rather than a full distance check, we do a crude check in both dimensions to see
                                                                                # if the cell is within a square-shaped region of the clump's center
            clump_cells.append(i) # Add this cell to the list
    if len(clump_cells)>0: # If we picked any cells...
        clump_cells=np.array(clump_cells)
        cells_area=np.sum(clump_cells[:,5]) # Add up the area of all the cells
        if cells_area > clump[4]*0.75: # If these cells combined make up 75% the area of the clump...
            keepClump=False # Discard this clump. Note that although it may seem difficult to reach this threshold,
                            # given that the square we check only has ~32% the area of the assumed circular shape
                            # of the aggregate, we are only checking that the CENTERS of cells are inside this square,
                            # and the cells themselves can substantially protrude in all directions. 
    
    if keepClump: # If we keep this clump, add it to the output file.
        f = open(path+filetype,'a') 
        f.write(str(clump[0]))
        for i in range(1,len(clump)):
            f.write(','+str(clump[i]))
        f.write('\n')
        f.close()