# This code (counts poisson judgment) is run on the  minute variance flags file
# generated by the minute variance labeler on 'frames counts flags' files
# generated by the spatial distribution labeler on E. coli cell datasets.
#
# Using previous information about the 'quality' of each minute of data, as
# well as the likelihood of cell count numbers changing from minute-to-minute
# as much as actually occurs, determines which minutes of data to keep and
# ultimate which minutes of data to throw out.
#
# This code creates a 'counts final' file representing the final AUTOMATED
# step in making a cell counts time series for the experiment. As the automated
# steps do not remove all suspect data, this file must subsequently be analyzed
# by hand and compared against images from the experiment.

import os
import sys
import numpy as np

expLabel = sys.argv[1]

path = expLabel
datefolder=path
filename = 'counts'
filetype = '.csv'
try: 
    os.makedirs(path)
except OSError:
    if not os.path.isdir(path):
        raise


path = os.path.join(expLabel,expLabel+'_' + filename)
f = open(path+filetype,'w')

data_file = open(os.path.join(os.path.join(expLabel,'temp_files'),expLabel+'_minute_variance_flags.csv'),'r')

endOfFile=False

data=np.genfromtxt(data_file, delimiter=",") # Load minutes variance flags file into Numpy array
minutes=data[:,0] # First column is minute number
counts=data[:,1] # Second column is average ('measured') counts per minute
stdevs=data[:,2] # Third column is standard deviation of measured counts per minute
flags=data[:,3] # Fourth column is minute variance flags estimating quality of data that minute

averageIndices=[] # We keep an array of the 5 most recent 'known good' time points.
for i in range(len(minutes)): # Search the whole file if we have to...
    if flags[i]<4: # If minute quality is better than a label of '4' (threshold determined empirically)
        averageIndices.append(i) # Save this index
        if len(averageIndices)>4: # Once we have 5 indices with 'good' minute quality, considering individual minutes only...
            break # Exit this loop

# Save these 5 minutes, which are assumed to be good enough to use as a starting point
f.write(str(minutes[averageIndices[0]])+","+str(counts[averageIndices[0]])+","+str(stdevs[averageIndices[0]])+"\n")  
f.write(str(minutes[averageIndices[1]])+","+str(counts[averageIndices[1]])+","+str(stdevs[averageIndices[1]])+"\n")  
f.write(str(minutes[averageIndices[2]])+","+str(counts[averageIndices[2]])+","+str(stdevs[averageIndices[2]])+"\n")  
f.write(str(minutes[averageIndices[3]])+","+str(counts[averageIndices[3]])+","+str(stdevs[averageIndices[3]])+"\n")  
f.write(str(minutes[averageIndices[4]])+","+str(counts[averageIndices[4]])+","+str(stdevs[averageIndices[4]])+"\n")  

numValidMinutes=5 # Number of minutes of data we're keeping; so far we have 5

for i in range(averageIndices[4]+1,len(minutes)): # Search rest of file...
    mean = np.mean(counts[averageIndices]) # Average number of cells across last 5 'known good' minutes
    stdev= np.max([np.std(averageIndices),np.sqrt(mean)])   # Use whatever's higher; the sample standard deviation over the last 5 'known good' minutes,
                                                            # or the predicted standard deviation assuming minute data represents Poisson counting
                                                            # Note: sample standard deviation is typically higher ('worse' than Poisson)
    if (np.fabs(counts[i]-mean)<3*stdev and flags[i]<5) or (counts[i]>0 and (i-averageIndices[0])>9):   # If next time point isn't awful and number of cells is within 3 standard deviations of the current estimate of cell number, or (just in case there actually
                                                                                                        # has been a rapid change) if it's been 10 minutes since we've added a time point AND cells were detected this minute
        f.write(str(minutes[i])+","+str(counts[i])+","+str(stdevs[i])+"\n") # Keep this minute!
        averageIndices.pop(0) # Remove the oldest 'known good' image
        averageIndices.append(i) # Add this one instead
        numValidMinutes+=1 # We're keeping one more minute of data
    elif np.fabs(counts[i]-mean)<4*stdev and flags[i]<4: # OR, if next time point is slightly higher quality but is within even FOUR standard deviations of current estimate, keep it too
        # We keep the time point; see above
        f.write(str(minutes[i])+","+str(counts[i])+","+str(stdevs[i])+"\n") 
        averageIndices.pop(0)
        averageIndices.append(i)
        numValidMinutes+=1

f.close()